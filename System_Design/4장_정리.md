
### 📌  처리율 제한 장치란 
 네트워크 시스템에서 처리율 제한 장치란, 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate) 을 제어하기 위한 장치이다.
여기서 트래픽이란, 인터넷상에서 송수신 되는 모든 통신의 양을 의미합니다.  

[장점]
- DoS 공격에 의한 자원 고갈 방지
- 비용 절감
    - 추가 요청에 대한 처리를 제한 → 서버를 많이 두지 않아 됨 (말 그대로, 제한이라고 생각)
    - third-party API 의 불필요한 과금을 방지 → ex) 신용 조회, 결제 api 등등
- 서버 과부하 방지
    - 봇에서 오는 트래픽이나 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러내는데 처리율 제한 장치를 활용  

### 처리율 제한 장치의 제어 위치 

1) 클라이언트

- 클라이언트의 요청은 쉽게 위변조가 가능하기 때문에, 일반적으로 클라이언트는 처리율 제한을 안정적으로 걸 수 있는 장소가 되지 못합니다.
- 또한, 모든 클라이언트의 구현을 통제하는 것도 어려울 수 있습니다.
 

2) 서버

- 처리율 장치를 서버쪽에 둔다면, 서버 1곳에서만 관리를 하면 되고, 내부에서만 통제하게 됩니다.
- 처리율 제한 장치를 API 서버에 두는 대신, 미들웨어를 만들어 서버로 오기 전에 통제하는 방법도 존재한다고 합니다.

### 📌 처리율 제한 알고리즘  
1. 토큰 버킷(token bucket)
2. 누출 버킷(leaky bucket)
3. 고정 윈도 카운터(fixed window counter)
4. 이동 윈도 로그(sliding window log)
5. 이동 윈도 카운터(sliding window counter)

### 처리율 한도 초과 트래픽의 처리  
- 한도 제한에 걸린 메세지는 나중에 처리하려 메세징 큐에 저장한다.  

### 분산 환경에서의 처리율 제한 장치의 구현  
- 경쟁 조건 (race condition) 
- 동기화 (synchronization)  

📗 1) 경쟁 조건 (race condition)

[처리율 제한장치의 간단한 동작과정]

- 레디스에서 카운터의 값을 읽는다.
- counter +1 의 값이 임계치를 넘는지 본다.
- 넘지 않는다면 레디스에 보관된 카운터 값을 1만큼 증가시킨다.

[경쟁조건이 일어나는 이유]

- 병행성이 심한 환경에서는, 두 개의 요청을 처리하는 스레드가, 하나의 값을 동시에 바꾼다고 하였을 떄 경쟁이 일어날 수 있다.
- 이렇게 되면, 데이터의 정합성이 깨지는 심각한 문제가 발생할 수 있습니다.

[경쟁조건 해결 방법]
- 가장 보편적인 방법은 락 (이전 글에서 쓴 동시성 처리 방법 예제들 참고하셔도 좋을거같아요)
- 루아 스크립트 (Lua Script)
    - 절차지향적 선언형 언어라고 하는데.. 아마 순차적으로 실행시켜서 경쟁을 없앤다는 느낌 같습니다. 
- 레디스 정렬 집합 (redis sorted set)
    - 참고문헌을 보면 sorted set 에 특별한 기능이 있어서 경쟁 이슈를 해결하는 것은 아니였으며, 로직의 문제였다고 합니다.
    - 참고 문헌 : https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/
 

📗  2) 동기화 (synchronization)

분산 서비스 환경에서, 여러대의 처리율 제한 장치를 사용할 경우 요청 또한 분산되기 때문에, 처리율 장치간의 (Counting 값) 동기화가 필요합니다 .


해결 방법

1. 고정 세션 (Sticky session)

고정 세션 (Sticky session) 을 사용하여 같은 클라이언트로부터의 요청은 항상 같은 처리율 제한 장치로 보낼 수 있도록 하여 해결할 수 있지만, 확장이 불가하고 유연하지 않기떄문에 추천하지 않는다고 합니다.

2. 중앙 집중형 데이터 저장수

레디스와 같은 중앙 집중형 데이터베이스를 사용하는것이 더 나은 해결책이라고 합니다.
 

