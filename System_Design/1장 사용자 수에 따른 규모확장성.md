책: 가상 면접 사례로 배우는 대규모 시스템 기초 

☑️ `목표` : 사용자 수가 증가함에 따라 시스템의 규모를 확장해 나가는 과정

☑️ 목차
- [단일서버](#🔸-단일-서버)
- [데이터베이스](#🔸-데이터베이스)
- [수직적 규모 확장 vs. 수평적 규모 확장](#🔸-수직적-규모-확장scale-up-vs-수평적-규모-확장scale-out)
- [로드 밸랜서](#🔸-로드-밸런서)
- [DB 다중화](#🔸-데이터베이스-다중화)
- [캐시](#🔸-캐시)
- [CDN](#🔸-cdn-콘텐츠-전송-네트워크)
- [무상태 웹 계층](#🔸-무상태-웹-계층)
- [데이터 센터](#🔸-데이터-센터)
- [메세지 큐](#🔸-메세지-큐)
- [DB 규모 확장](#🔸-데이터베이스-규모-확장)

### ||  🔸 단일 서버 
⭐ **컴포넌트가 단 한대에 서버에서 실행**하는 구성 

1.  사용자는 도메인 이름을 이용하여 웹사이트에 접속한다. 이 접속을 위해서는 도메인 이름을 DNS 에 질의하여 IP 주소로 변환하는 과정이 필요하다.
2.  DNS 조회로 웹 서버의 IP 주소가 반환된다.
3.  해당 IP 주소로 HTTP 요청이 전달된다.
4.  요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

### || 🔸 데이터베이스 

사용자가 늘면 웹/모바일 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층)을 분리하여 각각 독립적으로 확장해 나갈 수 있다.

[종류]
* RDBMS (관계형) : MySQL, 오라클, PostgreSQL
* NoSQL (비관계형):  CouchDB, Neo4j, Cassandra, HBase, MongoDB, Amazon DynamoDB 
	* 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소 네 부류로 나뉘어짐. 
	
🔺⁉️ 비관계형 데이터베이스 사용이 최적인 경우는? 
-   아주 <mark>낮은 응답 지연시간</mark>이 요구됨
-   다루는 데이터가 <mark>비정형</mark>이라 관계형 데이터가 아님
-   데이터를 직렬화하거나 역직렬화할 수 있기만 하면 됨
-   아주 많은 양의 데이터를 저장할 필요가 있음

### || 🔸 수직적 규모 확장(scale-up) vs. 수평적 규모 확장(scale-out)

✅ `수직적 규모 확장(scale-up)`
* 서버에 고사양 자원을 추가 (CPU, RAM, etc.)
* 트래픽이 적은 경우 좋은 선택
* 문제점 
	* 단일 컴퓨팅 파워에 한계가 있다. (한대의 서버에 무한대 증설 할 수 없다.)
	* 자동복구(failover) 나 다중화(redundancy) 방안이 없어 문제가 생기면 서비스가 종료 됨. 

✅ `수평적 규모 확장(scale-out)`
* 더 많은 서버 추가하여 성능 개선 
* ⭐ 대규모 애플리케이션 확장법으로 더 적절 

### || 🔸 로드 밸런서 

트래픽이 너무 많아지면 서버가 한계에 도달하여 응답속도가 느려지거나 접속이 불가능하다. 이것을 로드 밸런서가 해결한다. 
*  부하 분산 집합(load balancing set)에 속한 웹 서버들에게 ==트래픽 부하를 고르게 분산== 시켜줌 
* 웹서버 대신 로드밸런서의 공개 IP 주소 접속 (보안을 위해 사설 주소 사용하여 통신)
* 장점 
	* 자동 복구되지 못하는 문제 해소 (failover)
	* 웹 계층의 가용성 (availability) 향상 
		* 서버 1이 다운되면 서버2 로 전달
		* 트래픽 향상 되면 부하 분산 집합에 서버 추가 

### || 🔸 데이터베이스 다중화 

주(master) - 부(slave) 관계를 설정하여 데이터 원본은 주 서버에, 사본은 부 서버에 저장
* 주 서버 = 모든 쓰기 연산 지원
* 부 서버 = 주 서버로 부터 사본을 전달받아 읽기 연산 지원 
🔺⁉️ 이렇게 구성해도 괜찮은 이유는 대부분 읽기 연산의 비중이 쓰기 연산보다 많다. 

⭐장점 
* 더 나은 성능: 병렬 처리로 쿼리의 수가 늘어나 성능이 향상됨
* 안전성; 서버 일부가 파괴되어도 데이터 보존이 가능하다 => 지리적 떨어져 있는 곳으로 다중화 가능 
* 가용성 : 데이터 여러 지역 복제하여 장애가 생겨도 서비스를 이어갈 수 있음. 

🔺⁉️ 만약 주 서버가 다운되었다면? 
	=> 부 서버가 새로운 주 서버가 되고 일시적으로 쓰기/읽기 연산을 모두 처리 한다. 
🔺⁉️ 하나의 부 서버가 다운 되었을때? 
   => 읽기 연산을 주 서버로 전달하고 부 서버가 열어대 인경우는 나머지 읽기 연산이 나머지 부 서버로 분산된다. 

### || 🔸 캐시 

⭐ 응답시간 (latency) 개선 가능 
      - 응답시간 개선 방법 : (1) 캐시 (2) CDN 

* 비싼 연산 결과나 자주 참조되는 데이터를 메모리에 보관하고 요청이 빨리 처리될 수 있도록 함
* DB 에 얼마나 호출하는지에 관련되어 있다. 
* 캐시 계층의 장점?
	* 데이터베이스 보다 빠르다
	* 성능 개선
	* DB 부하 줄음
	* 캐시 계층을 독립적으로 확장 가능 
* 캐시전략 종류 : `읽기 주도형 캐시 전략(read-through caching strategy)`

* 유의점 
	* 갱신이 자주 일어나지 않고 참조가 빈번한 경우
	* 캐시는 휘발성 데이터로 중요한 데이터는 영속성 저장소에 저장
	* 만료 기한 정책을 잘 설정해야 한다. - 잛으면 DB 너무 자주 읽고 너무 길면 실제 데이터와 차이가 남 
	* `일관성` : 저장소의 원본을 갱신하는 연산과 캐시 갱신 연산을 단일 트랜잭션으로 처리한다. 
	* `SOF(Single Point of Failure)` 를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산한다. 
	* 캐시 메모리 과할당(overprovision) 해서 캐시에 보관할 데이터가 많을 경우 미리 방지
		* 캐시 메모리가 너무 작으면 = eviction (성능 떨어짐)
	* eviction 정책? 
		* 캐시가 꽉 차버리면 데이터를 내보내는 현상인데 LRU(recent)/LFU(frequent)/FIFO 가 있음.
		

### || 🔸 CDN 콘텐츠 전송 네트워크 
⭐정적 콘텐츠 (이미지, 비디오, CSS, Javascript) 를 지리적으로 분산된 서버의 네트워크이여서 사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다. 

☑️ [동작 과정]
1.  사용자가 이미지 URL을 이용해 이미지에 접근한다. ( URL 은 CDN 서비스 사업자가 제공) 
2.  CDN 서버에 이미지가 없는 경우 CDN 서버는 원본 서버에 요청해 파일을 가져온다. (ex. 원본 서버 = 웹 서버/ S3)
3.  원본 서버가 CDN 서버에 파일을 반환한다. 
	- HTTP 응답 헤더에는 해당 파일이 얼마나 오래 캐시될 수 있는지 나타내는 **TTL(Time-To-Live)** 값이 들어있다.
4.  CDN서버는 파일을 캐시하고 사용자에게 반환한다. 
	- 이미지 파일은 TTL에 명시된 시간만큼 캐시
5.  다른 사용자가 동일한 이미지를 CDN 서버에 요청한다.
6.  해당 이미지가 만료되지 않았다면 **CDN 서버가 캐시해둔 파일을 반환**한다.

* 고려 사항 
	* 비용: 3rd party provider 이 운영하여 데이터 전송량에 따라 요금 지불한다. 
	* 만료 시한 설정: time sensitive 한 콘텐츠는 만료시점 설정이 중요함. (캐시 서버 만료 정책과 비슷)
	* CDN 장애 대처 방안 
	* 콘텐츠 무효화(invalidation) : 만료되지 않은 콘텐츠도 CDN 에서 캐시 제거 
		* 사업자가 제공하는 API 통한 무료화
		* 다른 버전을 서비스 하도록 `object versioning` 을 url 마지막에 번호 인자를 줌 

### || 🔸 무상태 웹 계층 

**웹 계층을 수평 확장**하기 위해서는 사용자 세션 데이터와 같은 상태 정보를 웹 계층에서 제거해야한다.

> 상태 정보 의존적 아키텍쳐
* 서버는 클라이언트 정보 상태를 유지하여 요청들 사이에 공유(쿠키와 세션등을 사용하여)**되도록 한다
*  로드밸런서는 Sticky Session 기능을 제공하지만 부담을 준다. 

🔺Q. 왜 로드밸런서 뒷단에 서버를 추가하거나 제거하기 까다로워 지며 장애 처리가 복잡해지는가? 

> 무상태 아키택쳐 

상태 정보를 별도의 공유 저장소(shared storage)로부터 데이터를 저장하고 가져오며 상태 정보는 웹 서버로부터 물리적으로 분리되어 있다.  => 단순하고, 안정적이고, 규모 확장이 쉬움 

* 공유 저장소는 Memcached나 Redis와 같은 캐시 시스템/ 혹은 NoSQL 이 될 수 있음. 
* 상태를 별도의 저장소에 저장하여 부하 분산 집합내의 **자동 규모 확장(autoscaling)**이 가능해지고 상태가 웹 서버에서 제거되었으므로, 트래픽 양에 따라 웹 서버를 넣거나 빼기만 하면 자동으로 규모를 확장할 수 있다.

### || 🔸 데이터 센터 

용성을 높이고 **전세계 어디서든 쾌적하게 사용하기 위해 데이터 센터(data center)**를 지원한다. 

* 장애가 없는 상황에서 사용자는 가장 가까운 데이터센터로 라우팅
* **지리적 라우팅(geoDNS-routing 또는 geo-routing)** 
	* 사용자의 위치에 따라 도메인 이름을 어떤 IP주소로 변화할지 결정해주는 DNS 서비스
* 유의사항  
	* 트래픽 우회
	* 데이터 동기화 : 장애가 자동으로 복구되어(failover) 트래픽이 다른 데이터베이스로 우회된다 해도, 해당 데이터센터에는 찾는 데이터가 없을 수 있음. 
	* 테스트와 배포 

### || 🔸 메세지 큐 

* 시스템을 확장할때 **시스템의 컴포넌트를 분리(느슨한 결합, loose coupling)하고 각기 독립적으로 확장**될 수 있도록 하는데 메시지큐는 많은 실제 분산 시스템의 핵심 전략이다. 
* 메시지 큐는 **비동기 통신을 지원하는 컴포넌트**
	* **손실을 보장**하는 특징
		* 메시지 큐에 한번 저장된 메시지는 소비자가 꺼낼때 까지 안전히 보관됨 
* 발행자/구독자 
	* 생산자 또는 발행자(producer/publisher)**라고 불리는 입력 서비스가메시지를 만들어 메시지 큐에 발행(publish)
	* 메시지 큐에는 **소비자 혹은 구독자(consumer/subscriber)라고 불리는 서비스 또는 서버가 연결되어 있는데, 메시지를 받고 동작을 수행
	* 생산자는 소비자가 다운되어 있을때도 메시지를 발행할 수 있고, 반대로 소비자는 생산자 서비스가 다운되어 있더라도 메시지를 수신
* ⭐ 서버 간의 결합을 느슨히 해주고 결함에 대한 내성을 높여줌. 


### || 🔸 데이터베이스 규모 확장 

✅ 수직적 확장
	*  CPU, RAM, 디스크 자원 증설 
	* 단점 
		* 무한 증설 불가능
		* 하나의 DB 는 SPOF 위험성이 큼
		* 고성능 서버일수록 가격이 올라감 
		
✅ 수평적 확장 
	* `sharding` : 더 많은 서버를 추가함으로 성능 향상 
	* 대규모 데이터베-이스를 샤드 (작은 단위 분할)
		* 같은 스키마 사용 but 보관되는 데이터에 중복 없음. 

➡️ Sharding 
	- 해시 샤딩
		- 샤드의 개수에 따라 해시 함수를 사용하여 데이터가 보관될 샤드 결정 
		- 샤딩 키(parition key) : 데이터가 어떤 샤드에 저장될지 결정하는 하나 이상의 컬럼으로 구성 
	- 유의사항 
		- 데이터의 재 샤딩 
			- 데이터 너무 많아지거나 균등하게 분포되지 않은 경우 shard exhaustion (샤드 소진) 현상 발생. -> 안정 해시 기법이 대책 
		- 유명인사 문제 (celebrity) : 한 샤드에 집중적으로 질의 경우?
		- 조인과 비정규화 (join and denormalization) : 하나의 DB 를 여러 서버에 쪼개면 join 어려움

### || 🚩 정리 

시스템의 규모를 확장하는 것은 지속적이고 반복적(iterative)인 과정으로 계속 다듬어야 한다. 

-   웹 계층은 무상태 계층
-   모든 계층에 다중화 도입
-   가능한 한 많은 데이터를 캐시할 것
-   여러 데이터 센터를 지원할 것
-   정적 콘텐츠는 CDN을 통해 서비스할 것
-   데이터 계층은 샤딩을 통해 그 규모를 확장할 것
-   각 계층은 독립적 서비스로 분할할 것
-   시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것



[참고]

https://hudi.blog/system-design-interview-alex-xu-1/
[포스트 정리](https://velog.io/@haron/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88-1%EC%9E%A5-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B7%9C%EB%AA%A8-%ED%99%95%EC%9E%A5%EC%84%B1)
https://momoci99.github.io/BookReviewSystemDesignChapter1/


